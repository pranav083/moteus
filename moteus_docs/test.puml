@startuml





/' Objects '/

namespace moteus {
	class AS5047 {
		+AS5047(Options options)
		-spi_ : Stm32Spi
		+FinishSample() : uint16_t
		+Sample() : uint16_t
		+StartSample() : void
	}

	class Aksim2 {
		+Aksim2(const aux::UartEncoder::Config& config, Stm32G4DmaUart* uart, MillisecondTimer* timer)
		-timer_ : MillisecondTimer* const
		-uart_ : Stm32G4DmaUart* const
		-query_outstanding_ : bool
		-config_ : const aux::UartEncoder::Config
		-{static} kMaxCount : static constexpr int
		-{static} kResyncBytes : static constexpr int
		-last_query_start_us_ : uint32_t
		+ISR_Update(aux::UartEncoder::Status* status) : void
		+ProcessQuery(aux::UartEncoder::Status* status) : void
		-StartRead() : void
	}

	class AuxADC {
		+AuxADC()
		+{static} kMaxAdcs : static constexpr int
		+{static} kMaxPins : static constexpr int
		+ISR_EndSample() : void
		+ISR_StartSample() : void
		-UpdateConfig() : void
	}

	class AuxPort {
		+AuxPort(const char* aux_name, const char* icpz_name, const aux::AuxHardwareConfig& hw_config, AuxADC::AuxInfo* adc_info, mjlib::micro::PersistentConfig* persistent_config, mjlib::micro::CommandManager* command_manager, mjlib::micro::TelemetryManager* telemetry_manager, mjlib::micro::AsyncStream* tunnel_stream, MillisecondTimer* timer, SpiDefault spi_default, std::array<DMA_Channel_TypeDef*, 4> dma_channels)
		-adc_info_ : AuxADC::AuxInfo&
		-config_ : AuxConfig
		-status_ : AuxStatus
		+config() : Config* {query}
		-timer_ : MillisecondTimer* const
		+status() : Status*
		+debug_uart() : USART_TypeDef* {query}
		-any_adc_ : bool
		-any_isr_enabled_ : bool
		-i2c_startup_complete_ : bool
		-onboard_spi_available_ : bool
		-stream_write_outstanding_ : bool
		-tunnel_polling_enabled_ : bool
		-tunnel_write_outstanding_ : bool
		-hw_config_ : const aux::AuxHardwareConfig
		-dma_channels_ : const std::array<DMA_Channel_TypeDef*, 4>
		-{static} ParseHexByte(const char* value) : int
		-{static} ParseHexNybble(char c) : int
		-cosine_pin_ : int
		-sine_pin_ : int
		-tunnel_stream_ : mjlib::micro::AsyncStream* const
		-{static} kTunnelBufSize : static constexpr size_t
		-{static} AS5048_REG_AGC : static constexpr uint8_t
		-{static} AS5048_REG_ANGLE_HIGH : static constexpr uint8_t
		-{static} AS5048_REG_ANGLE_LOW : static constexpr uint8_t
		-{static} AS5048_REG_DIAG : static constexpr uint8_t
		-{static} AS5048_REG_MAG_HIGH : static constexpr uint8_t
		-{static} AS5048_REG_MAG_LOW : static constexpr uint8_t
		-{static} AS5600_REG_AGC : static constexpr uint8_t
		-{static} AS5600_REG_ANGLE_HIGH : static constexpr uint8_t
		-{static} AS5600_REG_ANGLE_LOW : static constexpr uint8_t
		-{static} AS5600_REG_MAG_HIGH : static constexpr uint8_t
		-{static} AS5600_REG_MAG_LOW : static constexpr uint8_t
		-{static} AS5600_REG_RAW_ANGLE_HIGH : static constexpr uint8_t
		-{static} AS5600_REG_RAW_ANGLE_LOW : static constexpr uint8_t
		-{static} AS5600_REG_STATUS : static constexpr uint8_t
		-i2c_state_ : std::array<I2cState, 3>
		-digital_inputs_ : std::array<std::optional<DigitalIn>, aux::AuxConfig::kNumPins>
		-digital_outputs_ : std::array<std::optional<DigitalOut>, aux::AuxConfig::kNumPins>
		-as5047_options_ : std::optional<AS5047::Options>
		-as5047_ : std::optional<AS5047>
		-aksim2_ : std::optional<Aksim2>
		-halla_ : std::optional<DigitalIn>
		-hallb_ : std::optional<DigitalIn>
		-hallc_ : std::optional<DigitalIn>
		-i2c_pullup_dout_ : std::optional<DigitalOut>
		-onboard_cs_ : std::optional<DigitalOut>
		-rs422_de_ : std::optional<DigitalOut>
		-rs422_re_ : std::optional<DigitalOut>
		-ic_pz_ : std::optional<IcPz>
		-uart_ : std::optional<Stm32G4DmaUart>
		-i2c_ : std::optional<Stm32I2c>
		-index_ : std::optional<aux::Stm32Index>
		-quad_ : std::optional<aux::Stm32Quadrature>
		-HandleCommand(const std::string_view& message, const mjlib::micro::CommandManager::Response& response) : void
		-HandleConfigUpdate() : void
		-HandleTunnelRead(const mjlib::micro::error_code& ec, std::ptrdiff_t size) : void
		+ISR_EndAnalogSample() : void
		+ISR_MaybeFinishSample() : void
		+ISR_MaybeStartSample() : void
		-ParseAs5048(aux::I2C::DeviceStatus* status) : void
		-ParseAs5600(aux::I2C::DeviceStatus* status) : void
		-ParseI2c(size_t index) : void
		+Poll() : void
		-PollI2c() : void
		+PollMillisecond() : void
		-StartI2cRead(uint8_t address, uint8_t reg) : void
		-StartTunnelRead() : void
		+WriteDigitalOut(uint32_t value) : void
		-WriteMessage(const mjlib::micro::CommandManager::Response& response, const std::string_view& message) : void
		-WriteOk(const mjlib::micro::CommandManager::Response& response) : void
	}

	class BldcServo {
		+BldcServo(mjlib::micro::Pool*, mjlib::micro::PersistentConfig*, mjlib::micro::TelemetryManager*, MillisecondTimer*, MotorDriver*, AuxADC*, AuxPort*, AuxPort*, MotorPosition*, Options &)
		+~BldcServo()
		+aux1() : AuxPort::Status& {query}
		+aux2() : AuxPort::Status& {query}
		+config() : Config& {query}
		+control() : Control& {query}
		+motor_position_config() : MotorPosition::Config*
		+motor_position_config() : MotorPosition::Config* {query}
		+motor_position() : MotorPosition::Status& {query}
		+status() : Status& {query}
		-impl_ : mjlib::micro::PoolPtr<Impl>
		+Command(BldcServoCommandData &) : void
		+PollMillisecond() : void
		+RequireReindex() : void
		+SetOutputPosition(float position) : void
		+SetOutputPositionNearest(float position) : void
		+Start() : void
	}

	class BldcServoPosition {
		+{static} CalculateAcceleration(BldcServoCommandData* data, float a, float v0, float vf, float dx, float dv) : float
		+{static} UpdateCommand(BldcServoStatus* status, const BldcServoConfig* config, const BldcServoPositionConfig* position_config, const MotorPosition::Status* position, int64_t absolute_relative_delta, float rate_hz, BldcServoCommandData* data, float velocity) : float
		+{static} DoVelocityAndAccelLimits(BldcServoStatus* status, const BldcServoConfig* config, float rate_hz, BldcServoCommandData* data, float velocity) : void
		+{static} DoVelocityModeLimits(BldcServoStatus* status, const BldcServoConfig* config, float rate_hz, BldcServoCommandData* data, float velocity) : void
		+{static} DoVelocityOnlyLimit(BldcServoStatus* status, float dx, BldcServoCommandData* data, float velocity, float period_s) : void
		+{static} UpdateTrajectory(BldcServoStatus* status, const BldcServoConfig* config, float rate_hz, BldcServoCommandData* data, float velocity) : void
	}

	class BoardDebug {
		+BoardDebug(mjlib::micro::Pool*, mjlib::micro::CommandManager*, mjlib::micro::TelemetryManager*, mjlib::multiplex::MicroServer*, BldcServo* bldc_servo)
		+~BoardDebug()
		-impl_ : mjlib::micro::PoolPtr<Impl>
		+PollMillisecond() : void
	}

	class ClockManager {
		+ClockManager(MillisecondTimer* timer, mjlib::micro::PersistentConfig& persistent_config, mjlib::micro::CommandManager& command_manager)
		-clock_ : Config
		-timer_ : MillisecondTimer* const
		-extra_trim_ : int
		+trim() : int {query}
		+{static} kMaxExtraTrim : static constexpr int
		+Command(const std::string_view& command, const mjlib::micro::CommandManager::Response& response) : void
		+SetTrim(int extra_trim) : void
		+UpdateConfig() : void
		+WriteMessage(const std::string_view& message, const mjlib::micro::CommandManager::Response& response) : void
	}

	class Cordic {
		+Cordic()
		+Cordic()
		+operator()(int32_t theta_q31) : SinCos {query}
		+operator()(int32_t theta_q31) : SinCos {query}
		+radians(float theta) : SinCos {query}
		+{static} from_q31(uint32_t val) : float
	}

	class Drv8323 {
		+Drv8323(mjlib::micro::Pool*, mjlib::micro::PersistentConfig* persistent_config, mjlib::micro::TelemetryManager* telemetry_manager, MillisecondTimer* timer, Options &)
		+~Drv8323()
		+status() : Status* {query}
		+fault() : bool
		-impl_ : mjlib::micro::PoolPtr<Impl>
		+Enable(bool) : void
		+PollMillisecond() : void
		+Power(bool) : void
	}

	class FDCan {
		+FDCan(Options options)
		+config() : Config {query}
		-config_ : Config
		-can_ : FDCAN_GlobalTypeDef*
		-hfdcan1_ : FDCAN_HandleTypeDef
		+status() : FDCAN_ProtocolStatusTypeDef
		-options_ : Options
		+Poll(FDCAN_RxHeaderTypeDef* header, mjlib::base::string_span) : bool
		+{static} ParseDlc(uint32_t dlc_code) : int
		-last_tx_request_ : uint32_t
		+ConfigureFilters(FilterConfig &) : void
		-Init() : void
		+RecoverBusOff() : void
		+Send(uint32_t dest_id, std::string_view data, SendOptions &) : void
	}

	class FDCanMicroServer {
		+FDCanMicroServer(FDCan* can)
		-fdcan_ : FDCan* const
		-current_read_header_ : Header*
		+properties() : Properties {query}
		-current_read_data_ : mjlib::base::string_span
		-current_read_callback_ : mjlib::micro::SizeCallback
		+{static} RoundUpDlc(size_t value) : size_t
		+{static} kBrsFlag : static constexpr uint32_t
		+{static} kFdcanFlag : static constexpr uint32_t
		-can_prefix_ : uint32_t
		+can_reset_count() : uint32_t {query}
		-can_reset_count_ : uint32_t
		+AsyncRead(Header* header, const mjlib::base::string_span& data, const mjlib::micro::SizeCallback& callback) : void
		+AsyncWrite(const Header& header, const std::string_view& data, const Header& query_header, const mjlib::micro::SizeCallback& callback) : void
		+Poll() : void
		+SetPrefix(uint32_t can_prefix) : void
	}

	class FirmwareInfo {
		+FirmwareInfo(mjlib::micro::Pool &, mjlib::micro::TelemetryManager &, uint32_t version, uint32_t model)
		+~FirmwareInfo()
		+serial_number() : SerialNumber {query}
		-impl_ : mjlib::micro::PoolPtr<Impl>
		+firmware_version() : uint32_t {query}
		+model_number() : uint32_t {query}
	}

	class IcPz {
		+IcPz(Options options, MillisecondTimer* timer)
		-timer_ : MillisecondTimer* const
		+status_ : Status
		+status() : Status&
		-spi_ : Stm32Spi
		-command_active_ : bool
		-{static} kAiPhases : static constexpr uint8_t
		-{static} kSpiReadDiagnosis : static constexpr uint8_t
		-{static} kSpiReadPosition : static constexpr uint8_t
		-{static} kSpiReadRegisters : static constexpr uint8_t
		-{static} kSpiWriteCommand : static constexpr uint8_t
		-{static} kSpiWriteRegisters : static constexpr uint8_t
		-{static} u32(T value) : uint32_t
		-extra_read_ : uint8_t
		-DmaTransfer(int size) : void
		+DoOperating() : void
		-EnterOperating() : void
		-ExitOperating() : void
		+ISR_MaybeFinishSample() : void
		+ISR_StartSample() : void
		-Initialize() : void
		+PollMillisecond() : void
		-PopulateOperatingBuffer() : void
		+ReadRegisters(uint8_t reg, mjlib::base::string_span output) : void
		+SetExtraRead(uint8_t bitfield) : void
		+StartCommand(uint8_t cmd) : void
		-StartDma(int size) : void
		-WriteConfigValue(ConfigValue config_value) : void
		-WriteRegister(uint8_t address, uint8_t value) : void
		+WriteRegisters(uint8_t reg, std::string_view data) : void
	}

	class MillisecondTimer {
		+MillisecondTimer()
		+read_ms() : TimerType
		+read_us() : TimerType
		+{static} subtract_us(uint16_t a, uint16_t b) : TimerType
		+wait_ms(uint32_t delay_ms) : void
		+wait_us(uint32_t delay_us) : void
		+wait_us_helper(uint32_t delay_us) : void
	}

	class MoteusController {
		+MoteusController(mjlib::micro::Pool*, mjlib::micro::PersistentConfig* config, mjlib::micro::CommandManager* command_manager, mjlib::micro::TelemetryManager* telemetry_manager, mjlib::multiplex::MicroServer* multiplex_protocol, ClockManager*, SystemInfo*, MillisecondTimer*, FirmwareInfo*)
		+~MoteusController()
		+bldc_servo() : BldcServo*
		-impl_ : mjlib::micro::PoolPtr<Impl>
		+multiplex_server() : mjlib::multiplex::MicroServer::Server*
		+Poll() : void
		+PollMillisecond() : void
		+Start() : void
	}

	abstract class MotorDriver {
		+{abstract} fault() : bool
		+{abstract} Enable(bool) : void
		+{abstract} Power(bool) : void
	}

	class MotorPosition {
		+MotorPosition(mjlib::micro::PersistentConfig* persistent_config, mjlib::micro::TelemetryManager* telemetry_manager, const aux::AuxStatus* aux1_status, const aux::AuxStatus* aux2_status, const aux::AuxConfig* aux1_config, const aux::AuxConfig* aux2_config)
		-inplace_function<void()
		-motor_ : BldcServoMotor
		+motor() : BldcServoMotor*
		-config_ : Config
		+config() : Config*
		-commutation_config_ : SourceConfig
		-output_config_ : SourceConfig
		-commutation_status_ : SourceStatus
		-output_status_ : SourceStatus
		-status_ : Status
		+status() : Status& {query}
		-ISR_UpdateAbsoluteSource(uint8_t nonce, uint32_t value, int32_t offset, int32_t sign, uint32_t cpr, SourceStatus status) : bool
		-IsThetaCapable(SourceConfig config) : bool {query}
		-aux_config_ : const aux::AuxConfig* const
		-aux_status_ : const aux::AuxStatus* const
		+{static} IntToFloat(int64_t value) : float
		+{static} WrapBalancedCpr(float value, float cpr) : float
		+{static} WrapCpr(float value, float cpr) : float
		-commutation_pole_scale_ : float
		-commutation_rotor_scale_ : float
		-output_cpr_scale_ : float
		-output_encoder_step_hb_1_4_ : int32_t
		-output_encoder_step_hb_3_4_ : int32_t
		+{static} FloatToInt(float value) : int64_t
		-output_encoder_step_ : int64_t
		+{static} kCompensationSize : static constexpr int
		+{static} kHallCounts : static constexpr int
		+{static} kNumSources : static constexpr int
		-pll_filter_constants_ : std::array<PllFilterConstants, kNumSources>
		+absolute_relative_delta : std::atomic<int32_t>
		+{static} WrapIntCpr(int32_t value, uint32_t cpr) : uint32_t
		-HandleConfigUpdate() : void
		+ISR_RequireReindex() : void
		+ISR_SetOutputPosition(float value) : void
		+ISR_SetOutputPositionNearest(float value) : void
		-ISR_SetOutputPositionNearestHelper(float value, int reference_source) : void
		+ISR_Update(float dt) : void
		-ISR_UpdateCommutation() : void
		-ISR_UpdateOutput() : void
		-ISR_UpdateSources(float dt) : void
		-ISR_UpdateState() : void
		+RegisterConfigUpdated(mjlib::base::inplace_function<void ( )> handler) : void
	}

	class PID {
		+PID(Config config, State state)
		-config_ : Config
		-state_ : State
		+Apply(float measured, float input_desired, float measured_rate, float input_desired_rate, int rate_hz, ApplyOptions apply_options) : float
	}

	class PID {
		+PID(Config config, State state)
		-config_ : Config
		-state_ : State
		+Apply(float measured, float input_desired, float measured_rate, float input_desired_rate, int rate_hz, ApplyOptions apply_options) : float
	}

	class SimplePI {
		+SimplePI(Config config, State state)
		-config_ : Config
		-state_ : State
		+Apply(float measured, float input_desired, int rate_hz) : float
	}

	class Stm32BitbangSpi {
		+Stm32BitbangSpi(MillisecondTimer* timer, Options options)
		+miso_ : DigitalIn
		+cs_ : DigitalOut
		+mosi_ : DigitalOut
		+sck_ : DigitalOut
		+timer_ : MillisecondTimer* const
		+options_ : Options
		+write(uint16_t value) : uint16_t
		+us_delay_ : uint32_t
	}

	class Stm32DigitalMonitor {
		+Stm32DigitalMonitor(PinName pin)
		+read() : bool
		-mask_ : uint32_t
		-reg_in_ : volatile uint32_t*
	}

	class Stm32Dma {
		+{static} SelectDmamux(DMA_Channel_TypeDef* channel) : DMAMUX_Channel_TypeDef*
		+{static} FindChannelIndex(DMA_Channel_TypeDef* channel) : uint32_t
		+{static} u32(T value) : uint32_t
	}

	class Stm32G4AsyncUart {
		+Stm32G4AsyncUart(mjlib::micro::Pool* pool, MillisecondTimer* timer, Options &)
		+~Stm32G4AsyncUart()
		-impl_ : mjlib::micro::PoolPtr<Impl>
		+AsyncReadSome(const mjlib::base::string_span &, const mjlib::micro::SizeCallback &) : void
		+AsyncWriteSome(const std::string_view &, const mjlib::micro::SizeCallback &) : void
		+Poll() : void
	}

	class Stm32G4DmaUart {
		+Stm32G4DmaUart(Options options)
		+~Stm32G4DmaUart()
		+dmamux_rx_ : DMAMUX_Channel_TypeDef*
		+dmamux_tx_ : DMAMUX_Channel_TypeDef*
		+options_ : Options
		+stm32_serial_ : Stm32Serial
		+uart() : USART_TypeDef* {query}
		+uart_ : USART_TypeDef*
		+is_dma_read_finished() : bool
		+is_dma_write_finished() : bool
		+read_bytes_remaining() : int
		+write_bytes_remaining() : int
		+{static} GetUartRxRequest(USART_TypeDef* uart) : uint32_t
		+{static} GetUartTxRequest(USART_TypeDef* uart) : uint32_t
		+{static} u32(T value) : uint32_t
		+finish_dma_read() : void
		+finish_dma_write() : void
		+start_dma_read(mjlib::base::string_span output) : void
		+start_dma_write(std::string_view data) : void
		+write_char(uint8_t data) : void
	}

	class Stm32G4Flash {
		+Stm32G4Flash()
		+~Stm32G4Flash()
		+GetInfo() : Info
		-shadow_start_ : uint32_t
		-shadow_ : uint64_t
		-shadow_bits_ : uint64_t
		+Erase() : void
		-FlushWord() : void
		+Lock() : void
		+ProgramByte(char* ptr, uint8_t value) : void
		+Unlock() : void
	}

	class Stm32GpioInterruptIn {
		+Stm32GpioInterruptIn(Stm32GpioInterruptIn&& rhs)
		+Stm32GpioInterruptIn(PinName pin, void (* ) ( uint32_t ) function, uint32_t val)
		+~Stm32GpioInterruptIn()
		-{static} entries_ : Callback
		-entry_ : Callback
		-{static} FindCallback(Callback cbk) : Callback*
		-{static} FindIrqN(int index) : IRQn_Type
		-pin_ : PinName
		+operator=(Stm32GpioInterruptIn&& rhs) : Stm32GpioInterruptIn&
		+read() : bool
		-{static} FindIrqIndex(PinName pin) : int
		-{static} irq_count(int i) : int&
		-{static} kMaxCallbacks : static constexpr int
		+{static} Make(PinName pin, void (* ) ( uint32_t ) function, uint32_t data) : std::optional<Stm32GpioInterruptIn>
		-mask_ : uint32_t
		-{static} ISR_Routine() : void
		-reg_in_ : volatile uint32_t*
	}

	class Stm32I2c {
		+Stm32I2c(Options options)
		-i2c_ : I2C_TypeDef*
		-mode_ : Mode
		-options_ : Options
		-valid_ : bool
		-mbed_i2c_ : i2c_t
		+CheckRead() : int
		-offset_ : int32_t
		-rx_data_ : mjlib::base::string_span
		-slave_address_ : uint8_t
		+Initialize() : void
		+Poll() : void
		+StartReadMemory(uint8_t slave_address, uint8_t address, mjlib::base::string_span data) : void
	}

	class Stm32Serial {
		+Stm32Serial(Options &)
		+uart_name() : UARTName {query}
		+huart() : UART_HandleTypeDef*
		+uart() : USART_TypeDef*
		-uart_ : USART_TypeDef*
	}

	class Stm32Spi {
		+Stm32Spi(Options options)
		-dmamux_rx_ : DMAMUX_Channel_TypeDef*
		-dmamux_tx_ : DMAMUX_Channel_TypeDef*
		-options_ : Options
		+is_dma_finished() : bool
		-spi_ : spi_t
		-cs_ : std::optional<DigitalOut>
		+finish_write() : uint16_t
		+write(uint16_t value) : uint16_t
		-{static} GetSpiRxRequest(SPI_TypeDef* spi) : uint32_t
		-{static} GetSpiTxRequest(SPI_TypeDef* spi) : uint32_t
		-{static} u32(T value) : uint32_t
		+finish_dma_transfer() : void
		+set_cs(PinName cs) : void
		+start_dma_transfer(std::string_view tx_buffer, mjlib::base::string_span rx_buffer) : void
		+start_write(uint16_t value) : void
	}

	class StreamWriter <template<size_t Size, size_t NumCallbacks=14>> {
		+StreamWriter(mjlib::micro::AsyncWriteStream* stream)
		-data1_ : Data
		-data2_ : Data
		-data_in_progress_ : Data
		-data_writing_ : Data
		-write_outstanding_ : bool
		-stream_ : mjlib::micro::AsyncWriteStream* const
		-current_offset_ : size_t
		+AsyncWrite(const std::string_view& buffer, const mjlib::micro::ErrorCallback& callback) : void
		-HandleWrite(const mjlib::micro::error_code& ec) : void
		-MaybeStartWrite() : void
	}

	class SystemInfo {
		+SystemInfo(mjlib::micro::Pool &, mjlib::micro::TelemetryManager &)
		+~SystemInfo()
		-impl_ : mjlib::micro::PoolPtr<Impl>
		+{static} idle_count : static volatile uint32_t
		+millisecond_counter() : uint32_t {query}
		+PollMillisecond() : void
		+SetCanResetCount(uint32_t) : void
	}

	class TorqueModel {
		+TorqueModel(float torque_constant, float current_cutoff_A, float current_scale, float torque_scale)
		+current_cutoff_A_ : const float
		+current_scale_ : const float
		+torque_constant_ : const float
		+torque_scale_ : const float
		+current_to_torque(float current) : float {query}
		+torque_to_current(float torque) : float {query}
	}

	class Uuid {
		+Uuid(mjlib::micro::PersistentConfig& config)
		+data_ : Data
	}

	enum AnalogFilter {
		kOff
		kOn
	}

	enum AuxPort::SpiDefault {
		kDefaultOnboardSpi
		kNoDefaultSpi
	}

	enum BldcServoMode {
		kBrake
		kCalibrating
		kCalibrationComplete
		kCurrent
		kEnabling
		kFault
		kMeasureInductance
		kNumModes
		kPosition
		kPositionTimeout
		kPwm
		kStayWithinBounds
		kStopped
		kVoltage
		kVoltageDq
		kVoltageFoc
		kZeroVelocity
	}

	enum Drv8323::OcpMode {
		kAutomaticRetry
		kIgnored
		kLatchedFault
		kNumOcpModes
		kReportNoAction
	}

	enum Drv8323::PwmMode {
		k1x
		k3x
		k6x
		kIndependent
		kNumPwmModes
	}

	enum FDCan::FilterAction {
		kAccept
		kDisable
		kReject
	}

	enum FDCan::FilterMode {
		kDual
		kMask
		kRange
	}

	enum FDCan::FilterType {
		kExtended
		kStandard
	}

	enum FDCan::Override {
		kDefault
		kDisable
		kRequire
	}

	enum I2cMode {
		kFast
		kFastPlus
		kStandard
	}

	enum IcPz::Mode {
		kCommand
		kOperating
		kWarmup
	}

	enum MotorPosition::SourceConfig::Reference {
		kOutput
		kRotor
	}

	enum MotorPosition::SourceConfig::Type {
		kHall
		kI2C
		kIndex
		kNone
		kNumTypes
		kQuadrature
		kSensorless
		kSineCosine
		kSpi
		kUart
	}

	enum MotorPosition::Status::Error {
		kInvalidConfig
		kMotorNotConfigured
		kNone
		kNumErrors
		kSourceError
	}

	enum MotorPosition::Status::Homed {
		kOutput
		kRelative
		kRotor
	}

	enum Stm32I2c::Mode {
		kComplete
		kError
		kIdle
		kReadingData
		kSentRegister
	}

	enum Stm32I2c::ReadStatus {
		kComplete
		kError
		kNoStatus
	}

	enum errc {
		kCalibrationFault
		kConfigChanged
		kDmaStreamFifoError
		kDmaStreamTransferError
		kEncoderFault
		kMotorDriverFault
		kMotorNotConfigured
		kOverTemperature
		kOverVoltage
		kPositionInvalid
		kPwmCycleOverrun
		kStartOutsideLimit
		kSuccess
		kThetaInvalid
		kUartBufferOverrunError
		kUartFramingError
		kUartNoiseError
		kUartOverrunError
		kUartParityError
		kUnderVoltage
	}

	class AuxADC::AdcConfig {
		+num_channels : int
	}

	class AuxADC::AuxInfo {
		+inplace_function<void()
	}

	class AuxADC::PinConfig {
		+adc_num : int
		+channel : int
	}

	class AuxPort::I2cState {
		+pending : bool
		+ms_since_last_poll : int32_t
	}

	class BldcServo::Control {
		+pwm : Vec3
		+voltage : Vec3
		+d_V : float
		+i_d_A : float
		+i_q_A : float
		+q_V : float
		+q_comp_A : float
		+torque_Nm : float
		+Clear() : void
		+Serialize(Archive* a) : void
	}

	class BldcServo::Options {
		+current1 : PinName
		+current2 : PinName
		+current3 : PinName
		+debug_dac : PinName
		+debug_out : PinName
		+debug_out2 : PinName
		+debug_uart_out : PinName
		+msense : PinName
		+pwm1 : PinName
		+pwm2 : PinName
		+pwm3 : PinName
		+tsense : PinName
		+vsense : PinName
	}

	class BldcServoCommandData {
		+mode : BldcServoMode
		+phase_v : Vec3
		+pwm : Vec3
		+accel_limit : float
		+bounds_max : float
		+bounds_min : float
		+d_V : float
		+feedforward_Nm : float
		+fixed_voltage_override : float
		+i_d_A : float
		+i_q_A : float
		+kd_scale : float
		+kp_scale : float
		+max_torque_Nm : float
		+position : float
		+q_V : float
		+stop_position : float
		+theta : float
		+theta_rate : float
		+timeout_s : float
		+velocity : float
		+velocity_limit : float
		+voltage : float
		+meas_ind_period : int8_t
		+position_relative_raw : std::optional<int64_t>
		+stop_position_relative_raw : std::optional<int64_t>
		+Serialize(Archive* a) : void
	}

	class BldcServoConfig {
		+BldcServoConfig()
		+pid_position : PID::Config
		+pid_dq : SimplePI::Config
		+enable_motor_temperature : bool
		+fixed_voltage_mode : bool
		+voltage_mode_control : bool
		+bemf_feedforward : float
		+current_feedforward : float
		+current_sense_ohm : float
		+default_accel_limit : float
		+default_timeout_s : float
		+default_velocity_limit : float
		+derate_current_A : float
		+derate_temperature : float
		+fault_temperature : float
		+fixed_voltage_control_V : float
		+flux_brake_min_voltage : float
		+flux_brake_resistance_ohm : float
		+i_gain : float
		+{static} invalid_float() : float
		+max_current_A : float
		+max_position_slip : float
		+max_power_W : float
		+max_velocity : float
		+max_velocity_derate : float
		+max_voltage : float
		+motor_derate_temperature : float
		+motor_fault_temperature : float
		+position_derate : float
		+pwm_comp_mag : float
		+pwm_comp_off : float
		+pwm_scale : float
		+timeout_max_torque_Nm : float
		+velocity_threshold : float
		+velocity_zero_capture_threshold : float
		+adc_aux_cycles : uint16_t
		+adc_cur_cycles : uint16_t
		+adc_prescale : uint16_t
		+cooldown_cycles : uint16_t
		+pwm_rate_hz : uint16_t
		+emit_debug : uint32_t
		+timeout_mode : uint8_t
		+Serialize(Archive* a) : void
	}

	class BldcServoMotor {
		+cogging_dq_scale : float
		+resistance_ohm : float
		+rotation_current_cutoff_A : float
		+rotation_current_scale : float
		+rotation_torque_scale : float
		+v_per_hz : float
		+phase_invert : uint8_t
		+poles : uint8_t
		+Serialize(Archive* a) : void
	}

	class BldcServoPositionConfig {
		+position_max : float
		+position_min : float
		+Serialize(Archive* a) : void
	}

	class BldcServoStatus {
		+mode : BldcServoMode
		+dwt : Dwt
		+pid_position : PID::State
		+pid_d : SimplePI::State
		+pid_q : SimplePI::State
		+trajectory_done : bool
		+fault : errc
		+bus_V : float
		+control_position : float
		+cos : float
		+cur1_A : float
		+cur2_A : float
		+cur3_A : float
		+d_A : float
		+fet_temp_C : float
		+filt_1ms_bus_V : float
		+filt_bus_V : float
		+filt_fet_temp_C : float
		+filt_motor_temp_C : float
		+meas_ind_integrator : float
		+meas_ind_old_d_A : float
		+motor_temp_C : float
		+position : float
		+position_to_set : float
		+q_A : float
		+sin : float
		+timeout_s : float
		+torque_Nm : float
		+torque_error_Nm : float
		+velocity : float
		+velocity_filt : float
		+meas_ind_phase : int8_t
		+control_velocity : std::optional<float>
		+control_position_raw : std::optional<int64_t>
		+adc_cur1_offset : uint16_t
		+adc_cur1_raw : uint16_t
		+adc_cur2_offset : uint16_t
		+adc_cur2_raw : uint16_t
		+adc_cur3_offset : uint16_t
		+adc_cur3_raw : uint16_t
		+adc_fet_temp_raw : uint16_t
		+adc_motor_temp_raw : uint16_t
		+adc_voltage_sense_raw : uint16_t
		+cooldown_count : uint16_t
		+final_timer : uint32_t
		+total_timer : uint32_t
		+Serialize(Archive* a) : void
	}

	class BldcServoStatus::Dwt {
		+adc_done : uint32_t
		+control : uint32_t
		+control_done_cur : uint32_t
		+control_done_pos : uint32_t
		+control_sel_mode : uint32_t
		+curstate : uint32_t
		+done : uint32_t
		+done_pos_sample : uint32_t
		+done_temp_sample : uint32_t
		+sense : uint32_t
		+start_pos_sample : uint32_t
		+Serialize(Archive* a) : void
	}

	class ClarkTransform {
		+ClarkTransform(float a, float b, float c)
		+x : const float
		+y : const float
	}

	class ClockManager::Config {
		+hsitrim : int32_t
		+Serialize(Archive* a) : void
	}

	class DqTransform {
		+DqTransform(const SinCos& sc, float a, float b, float c)
		+d : const float
		+q : const float
	}

	class Drv8323::Config {
		+ocp_mode : OcpMode
		+pwm_mode : PwmMode
		+cbc : bool
		+csa_fet : bool
		+dis_cpuv : bool
		+dis_gdf : bool
		+dis_sen : bool
		+ls_ref : bool
		+otw_rep : bool
		+pwm_1x_asynchronous : bool
		+pwm_1x_dir : bool
		+tretry : bool
		+vref_div : bool
		+{static} invalid_int() : int
		+dead_time_ns : uint16_t
		+idriven_hs_ma : uint16_t
		+idriven_ls_ma : uint16_t
		+idrivep_hs_ma : uint16_t
		+idrivep_ls_ma : uint16_t
		+sen_lvl_mv : uint16_t
		+tdrive_ns : uint16_t
		+vds_lvl_mv : uint16_t
		+csa_gain : uint8_t
		+ocp_deg_us : uint8_t
		+Serialize(Archive* a) : void
	}

	class Drv8323::Options {
		+cs : PinName
		+enable : PinName
		+fault : PinName
		+hiz : PinName
		+miso : PinName
		+mosi : PinName
		+sck : PinName
	}

	class Drv8323::Status {
		+cpuv : bool
		+enabled : bool
		+fault : bool
		+fault_line : bool
		+gdf : bool
		+otsd : bool
		+otw : bool
		+power : bool
		+sa_oc : bool
		+sb_oc : bool
		+sc_oc : bool
		+uvlo : bool
		+vds_ha : bool
		+vds_hb : bool
		+vds_hc : bool
		+vds_la : bool
		+vds_lb : bool
		+vds_lc : bool
		+vds_ocp : bool
		+vgs_ha : bool
		+vgs_hb : bool
		+vgs_hc : bool
		+vgs_la : bool
		+vgs_lb : bool
		+vgs_lc : bool
		+config_count : uint16_t
		+fsr1 : uint16_t
		+fsr2 : uint16_t
		+status_count : uint16_t
		+fault_config : uint8_t
		+Serialize(Archive* a) : void
	}

	class FDCan::Config {
		+data : Rate
		+nominal : Rate
		+clock : int
	}

	class FDCan::Filter {
		+action : FilterAction
		+mode : FilterMode
		+type : FilterType
		+id1 : uint32_t
		+id2 : uint32_t
	}

	class FDCan::FilterConfig {
		+begin : Filter
		+end : Filter
		+global_ext_action : FilterAction
		+global_remote_ext_action : FilterAction
		+global_remote_std_action : FilterAction
		+global_std_action : FilterAction
	}

	class FDCan::Options {
		+Options()
		+filters : FilterConfig
		+rd : PinName
		+td : PinName
		+fdrate_override : Rate
		+rate_override : Rate
		+automatic_retransmission : bool
		+bitrate_switch : bool
		+bus_monitor : bool
		+delay_compensation : bool
		+fdcan_frame : bool
		+remote_frame : bool
		+restricted_mode : bool
		+fast_bitrate : int
		+slow_bitrate : int
		+tdc_filter : uint32_t
		+tdc_offset : uint32_t
	}

	class FDCan::Rate {
		+prescaler : int
		+sync_jump_width : int
		+time_seg1 : int
		+time_seg2 : int
	}

	class FDCan::SendOptions {
		+SendOptions()
		+bitrate_switch : Override
		+extended_id : Override
		+fdcan_frame : Override
		+remote_frame : Override
	}

	class FamilyAndVersion {
		+family : int
		+hw_pins : int
		+hw_version : int
	}

	class FirmwareInfo::SerialNumber {
	}

	class GitInfo {
		+GitInfo()
		+dirty : bool
		+timestamp : uint64_t
		+Serialize(Archive* a) : void
	}

	class IcPz::ConfigValue {
		+address : uint8_t
		+bank : uint8_t
		+value : uint8_t
	}

	class IcPz::Options {
		+resolution_bits : uint8_t
	}

	class IcPz::Status {
		+abz_not_ready : bool
		+active : bool
		+ana_bound : bool
		+dig_bound : bool
		+dig_not_steady : bool
		+dig_sat : bool
		+err : bool
		+interp_err : bool
		+led_cur_low : bool
		+pos_alpha : bool
		+pos_omega : bool
		+prc_sync_failed : bool
		+temp1 : bool
		+temp2 : bool
		+temp_not_steady : bool
		+uvw_not_ready : bool
		+vddio_low : bool
		+warn : bool
		+ai_phases : float
		+ai_scales : float
		+value : uint32_t
		+adi : uint8_t
		+cmd : uint8_t
		+cmd_stat : uint8_t
		+dig : uint8_t
		+nonce : uint8_t
		+Serialize(Archive* a) : void
	}

	class InverseClarkTransform {
		+InverseClarkTransform(float x, float y)
		+a : const float
		+b : const float
		+c : const float
	}

	class InverseDqTransform {
		+InverseDqTransform(const SinCos& sc, float d, float q)
		+a : const float
		+b : const float
		+c : const float
	}

	class InverseParkTransform {
		+InverseParkTransform(const SinCos& sc, float d, float q)
		+x : const float
		+y : const float
	}

	class MoteusHwPins {
		+as5047_cs : PinName
		+can_rd : PinName
		+can_td : PinName
		+current1 : PinName
		+current2 : PinName
		+current3 : PinName
		+debug1 : PinName
		+debug2 : PinName
		+debug_dac : PinName
		+debug_led1 : PinName
		+drv8323_cs : PinName
		+drv8323_enable : PinName
		+drv8323_fault : PinName
		+drv8323_hiz : PinName
		+drv8323_miso : PinName
		+drv8323_mosi : PinName
		+drv8323_sck : PinName
		+msense : PinName
		+power_led : PinName
		+pwm1 : PinName
		+pwm2 : PinName
		+pwm3 : PinName
		+tsense : PinName
		+uart_dir : PinName
		+uart_rx : PinName
		+uart_tx : PinName
		+vsense : PinName
		+vsense_adc_scale : float
		+firmware_version : uint32_t
		+model_number : uint32_t
	}

	class MotorPosition::Config {
		+Config()
		+output : Output
		+rotor_to_output_ratio : float
		+commutation_source : int8_t
		+sources : std::array<SourceConfig, kNumSources>
		+Serialize(Archive* a) : void
	}

	class MotorPosition::Config::Output {
		+offset : float
		+reference_source : int8_t
		+sign : int8_t
		+source : int8_t
		+Serialize(Archive* a) : void
	}

	class MotorPosition::PllFilterConstants {
		+ki : float
		+kp : float
	}

	class MotorPosition::SourceConfig {
		+reference : Reference
		+type : Type
		+offset : float
		+pll_filter_hz : float
		+debug_override : int32_t
		+incremental_index : int8_t
		+sign : int8_t
		+cpr : uint32_t
		+aux_number : uint8_t
		+i2c_device : uint8_t
		+Serialize(Archive* a) : void
	}

	class MotorPosition::SourceStatus {
		+active_absolute : bool
		+active_theta : bool
		+active_velocity : bool
		+compensated_value : float
		+filtered_value : float
		+time_since_update : float
		+velocity : float
		+offset_value : uint32_t
		+raw : uint32_t
		+nonce : uint8_t
		+Serialize(Archive* a) : void
	}

	class MotorPosition::Status {
		+error : Error
		+homed : Homed
		+position_relative_valid : bool
		+theta_valid : bool
		+electrical_theta : float
		+position : float
		+position_relative : float
		+velocity : float
		+position_raw : int64_t
		+position_relative_modulo : int64_t
		+position_relative_raw : int64_t
		+epoch : uint8_t
		+Serialize(Archive* a) : void
	}

	class PID::ApplyOptions {
		+ApplyOptions()
		+kd_scale : float
		+kp_scale : float
	}

	class PID::ApplyOptions {
		+ApplyOptions()
		+kd_scale : float
		+ki_scale : float
		+kp_scale : float
	}

	class PID::Config {
		+ilimit : float
		+iratelimit : float
		+kd : float
		+ki : float
		+kp : float
		+max_desired_rate : float
		+sign : int8_t
		+Serialize(Archive* a) : void
	}

	class PID::Config {
		+ilimit : float
		+iratelimit : float
		+kd : float
		+ki : float
		+kp : float
		+max_desired_rate : float
		+sign : int8_t
		+Serialize(Archive* a) : void
	}

	class PID::State {
		+command : float
		+d : float
		+desired : float
		+error : float
		+error_rate : float
		+integral : float
		+p : float
		+pd : float
		+Clear() : void
		+Serialize(Archive* a) : void
	}

	class PID::State {
		+command : float
		+d : float
		+desired : float
		+error : float
		+error_rate : float
		+integral : float
		+p : float
		+pd : float
		+Clear() : void
		+Serialize(Archive* a) : void
	}

	class ParkTransform {
		+ParkTransform(const SinCos& sc, float x, float y)
		+d : const float
		+q : const float
	}

	class SimplePI::Config {
		+ki : float
		+kp : float
		+Serialize(Archive* a) : void
	}

	class SimplePI::State {
		+command : float
		+desired : float
		+error : float
		+integral : float
		+p : float
		+Clear() : void
		+Serialize(Archive* a) : void
	}

	class SinCos {
		+c : float
		+s : float
	}

	class Stm32BitbangSpi::Options {
		+cs : PinName
		+miso : PinName
		+mosi : PinName
		+sck : PinName
		+frequency : int
		+mode : int
		+width : int
	}

	class Stm32G4AsyncUart::Options {
		+rx_dma : DMA_Channel_TypeDef*
		+tx_dma : DMA_Channel_TypeDef*
		+dir : PinName
		+rx : PinName
		+tx : PinName
		+baud_rate : int
		+rx_buffer_size : size_t
		+disable_delay_us : uint8_t
		+enable_delay_us : uint8_t
	}

	class Stm32G4DmaUart::Options {
		+rx_dma : DMA_Channel_TypeDef*
		+tx_dma : DMA_Channel_TypeDef*
		+rx : PinName
		+tx : PinName
		+baud_rate : int
	}

	class Stm32GpioInterruptIn::Callback {
		+Callback()
		+Callback(void (* ) ( uint32_t ) function_in, uint32_t data_in)
		+ref_count : int
		+data : uint32_t
	}

	class Stm32I2c::Options {
		+i2c_mode : I2cMode
		+scl : PinName
		+sda : PinName
		+frequency : int
	}

	class Stm32Serial::Options {
		+rx : PinName
		+tx : PinName
		+baud_rate : int
	}

	class Stm32Spi::Options {
		+rx_dma : DMA_Channel_TypeDef*
		+tx_dma : DMA_Channel_TypeDef*
		+cs : PinName
		+miso : PinName
		+mosi : PinName
		+sck : PinName
		+frequency : int
		+mode : int
		+width : int
		+timeout : uint16_t
	}

	class StreamWriter::Data {
		+callbacks : std::array<mjlib::micro::ErrorCallback, NumCallbacks>
	}

	class TimingInput {
		+analog_filter : AnalogFilter
		+i2c_mode : I2cMode
		+fall_time_ns : int
		+i2c_hz : int
		+peripheral_hz : int
		+rise_time_ns : int
	}

	class TimingResult {
		+digital_noise_filter : int
		+error : int
		+prescaler : int
		+scldel : int
		+sclh : int
		+scll : int
		+sdadel : int
		+timingr : uint32_t
	}

	class Uuid::Data {
		+Serialize(Archive* a) : void
	}

	class Vec3 {
		+a : float
		+b : float
		+c : float
		+Serialize(Archive* ar) : void
	}

	namespace detail {
		class float_long {
			+f : float
			+l : long
		}
	}

	namespace aux {
		class Stm32Index {
			+Stm32Index(const Index::Config& config, const PinArray& array, const AuxHardwareConfig& hw_config)
			+error() : aux::AuxError
			-error_ : aux::AuxError
			-index_ : std::optional<DigitalIn>
			+ISR_Update(aux::Index::Status* status) : void
		}

		class Stm32Quadrature {
			+Stm32Quadrature(const Quadrature::Config& config, aux::Quadrature::Status* status, const PinArray& array, const AuxHardwareConfig& hw_config)
			-status_ : Quadrature::Status* const
			-hwtimer_ : TIM_TypeDef*
			+error() : aux::AuxError
			-error_ : aux::AuxError
			-config_ : const Quadrature::Config
			-a_in_ : std::optional<DigitalIn>
			-b_in_ : std::optional<DigitalIn>
			-a_ : std::optional<Stm32GpioInterruptIn>
			-b_ : std::optional<Stm32GpioInterruptIn>
			-old_timer_cnt_ : uint32_t
			+ISR_Callback() : void
			+{static} ISR_CallbackDelegate(uint32_t my_this) : void
			+ISR_Update(aux::Quadrature::Status* status) : void
		}

		enum AuxError {
			kAdcPinError
			kHallPinError
			kI2cPinError
			kIndexPinError
			kLength
			kNone
			kNotConfigured
			kQuadPinError
			kSineCosinePinError
			kSpiPinError
			kUartPinError
			kUnsupported
		}

		enum I2C::DeviceConfig::Type {
			kAs5048
			kAs5600
			kNone
			kNumTypes
		}

		enum Pin::Mode {
			kAnalogInput
			kCosine
			kDigitalInput
			kDigitalOutput
			kDir
			kHall
			kI2C
			kIndex
			kLength
			kNC
			kQuadratureHardware
			kQuadratureSoftware
			kRcPwm
			kSine
			kSpi
			kSpiCs
			kStep
			kUart
		}

		enum Pin::Pull {
			kNone
			kOpenDrain
			kPullDown
			kPullUp
		}

		enum RequireCs {
			kDoNotRequireCs
			kRequireCs
		}

		enum Spi::Config::Mode {
			kAs5047
			kDisabled
			kIcPz
			kNumModes
			kOnboardAs5047
		}

		enum UartEncoder::Config::Mode {
			kAksim2
			kDebug
			kDisabled
			kNumModes
			kTunnel
		}

		class AuxConfig {
			+hall : aux::Hall::Config
			+i2c : aux::I2C::Config
			+index : aux::Index::Config
			+quadrature : aux::Quadrature::Config
			+sine_cosine : aux::SineCosine::Config
			+spi : aux::Spi::Config
			+uart : aux::UartEncoder::Config
			+i2c_startup_delay_ms : int32_t
			+{static} kNumPins : static constexpr size_t
			+Serialize(Archive* a) : void
		}

		class AuxExtraOptions {
			+i2c_pullup : PinName
			+rs422_de : PinName
			+rs422_re : PinName
		}

		class AuxHardwareConfig {
			+pins : std::array<AuxPinConfig, 8>
		}

		class AuxPinConfig {
			+i2c : I2C_TypeDef*
			+mbed : PinName
			+spi : SPI_TypeDef*
			+timer : TIM_TypeDef*
			+uart : USART_TypeDef*
			+adc_num : int
			+adc_sqr : int
			+number : int
		}

		class AuxStatus {
			+error : AuxError
			+hall : Hall::Status
			+i2c : I2C::Status
			+index : Index::Status
			+quadrature : Quadrature::Status
			+sine_cosine : SineCosine::Status
			+spi : Spi::Status
			+uart : UartEncoder::Status
			+analog_bit_active : uint8_t
			+gpio_bit_active : uint8_t
			+Serialize(Archive* a) : void
		}

		class Hall {
		}

		class Hall::Config {
			+enabled : bool
			+polarity : uint8_t
			+Serialize(Archive* a) : void
		}

		class Hall::Status {
			+active : bool
			+error : uint16_t
			+bits : uint8_t
			+count : uint8_t
			+Serialize(Archive* a) : void
		}

		class I2C {
		}

		class I2C::Config {
			+pullup : bool
			+i2c_hz : int32_t
			+i2c_mode : int32_t
			+Serialize(Archive* a) : void
		}

		class I2C::DeviceConfig {
			+type : Type
			+poll_ms : int32_t
			+address : uint8_t
			+Serialize(Archive* a) : void
		}

		class I2C::DeviceStatus {
			+active : bool
			+ams_mag : uint16_t
			+value : uint16_t
			+error_count : uint32_t
			+ams_agc : uint8_t
			+ams_diag : uint8_t
			+nonce : uint8_t
			+Serialize(Archive* a) : void
		}

		class I2C::Status {
			+Serialize(Archive* a) : void
		}

		class Index {
		}

		class Index::Config {
			+enabled : bool
			+Serialize(Archive* a) : void
		}

		class Index::Status {
			+active : bool
			+raw : bool
			+value : bool
			+Serialize(Archive* a) : void
		}

		class Pin {
			+mode : Mode
			+pull : Pull
			+Serialize(Archive* a) : void
		}

		class Quadrature {
		}

		class Quadrature::Config {
			+enabled : bool
			+cpr : uint32_t
			+Serialize(Archive* a) : void
		}

		class Quadrature::Status {
			+active : bool
			+error : uint16_t
			+value : uint32_t
			+pins : uint8_t
			+Serialize(Archive* a) : void
		}

		class SineCosine {
		}

		class SineCosine::Config {
			+enabled : bool
			+common : uint16_t
			+Serialize(Archive* a) : void
		}

		class SineCosine::Status {
			+active : bool
			+cosine_raw : uint16_t
			+sine_raw : uint16_t
			+value : uint16_t
			+Serialize(Archive* a) : void
		}

		class Spi {
		}

		class Spi::Config {
			+mode : Mode
			+rate_hz : uint32_t
			+Serialize(Archive* a) : void
		}

		class Spi::Status {
			+active : bool
			+value : uint32_t
			+ic_pz_bits : uint8_t
			+nonce : uint8_t
			+Serialize(Archive* a) : void
		}

		class SpiPinOption {
			+cs : PinName
			+miso : PinName
			+mosi : PinName
			+sck : PinName
			+spi : SPI_TypeDef*
		}

		class UartEncoder {
		}

		class UartEncoder::Config {
			+mode : Mode
			+rs422 : bool
			+baud_rate : int32_t
			+poll_rate_us : int32_t
			+Serialize(Archive* a) : void
		}

		class UartEncoder::Status {
			+active : bool
			+aksim2_err : bool
			+aksim2_warn : bool
			+aksim2_status : uint16_t
			+value : uint32_t
			+nonce : uint8_t
			+Serialize(Archive* a) : void
		}

		class UartPinOption {
			+rx : PinName
			+tx : PinName
			+uart : USART_TypeDef*
		}
	}
}


namespace mjlib {
	namespace micro {
		class is_error_code_enummoteus::errc <template<>> {
		}
	}

	namespace base {
		class IsEnummoteus::BldcServoMode <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<M , char*>, M::kNumModes>
		}

		class IsEnummoteus::Drv8323::OcpMode <template<>> {
			+{static} value : static constexpr bool
			+{static} >(O::kNumOcpModes )>map () : std::array<std::pair<O , char*>, static_cast<int
		}

		class IsEnummoteus::Drv8323::PwmMode <template<>> {
			+{static} value : static constexpr bool
			+{static} >(P::kNumPwmModes )>map () : std::array<std::pair<P , char*>, static_cast<int
		}

		class IsEnummoteus::MotorPosition::SourceConfig::Reference <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<R , char*>, 2>
		}

		class IsEnummoteus::MotorPosition::SourceConfig::Type <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<T , char*>, T::kNumTypes>
		}

		class IsEnummoteus::MotorPosition::Status::Error <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<E , char*>, E::kNumErrors>
		}

		class IsEnummoteus::MotorPosition::Status::Homed <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<H , char*>, 3>
		}

		class IsEnummoteus::aux::AuxError <template<>> {
			+{static} value : static constexpr bool
			+{static} >(A::kLength )>map () : std::array<std::pair<A , char*>, static_cast<int
		}

		class IsEnummoteus::aux::I2C::DeviceConfig::Type <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<T , char*>, T::kNumTypes>
		}

		class IsEnummoteus::aux::Pin::Mode <template<>> {
			+{static} value : static constexpr bool
			+{static} >(P::kLength )>map () : std::array<std::pair<P , char*>, static_cast<int
		}

		class IsEnummoteus::aux::Pin::Pull <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<P , char*>, 4>
		}

		class IsEnummoteus::aux::Spi::Config::Mode <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<M , char*>, M::kNumModes>
		}

		class IsEnummoteus::aux::UartEncoder::Config::Mode <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<M , char*>, M::kNumModes>
		}

		class IsEnummoteus::errc <template<>> {
			+{static} value : static constexpr bool
			+{static} map() : std::array<std::pair<moteus::errc , char*>, 0>
		}
	}
}





/' Inheritance relationships '/

moteus.MotorDriver <|-- moteus.Drv8323


moteus.Stm32Spi::Options <|-- moteus.IcPz::Options





/' Aggregation relationships '/

moteus.AS5047 *-- moteus.Stm32Spi


moteus.Aksim2 o-- moteus.MillisecondTimer


moteus.Aksim2 o-- moteus.Stm32G4DmaUart


moteus.Aksim2 *-- moteus.aux.UartEncoder


moteus.Aksim2 *-- moteus.aux.UartEncoder::Config


moteus.aux.AuxConfig *-- moteus.aux.Hall


moteus.aux.AuxConfig *-- moteus.aux.Hall::Config


moteus.aux.AuxConfig *-- moteus.aux.I2C


moteus.aux.AuxConfig *-- moteus.aux.I2C::Config


moteus.aux.AuxConfig *-- moteus.aux.Index


moteus.aux.AuxConfig *-- moteus.aux.Index::Config


moteus.aux.AuxConfig *-- moteus.aux.Quadrature


moteus.aux.AuxConfig *-- moteus.aux.Quadrature::Config


moteus.aux.AuxConfig *-- moteus.aux.SineCosine


moteus.aux.AuxConfig *-- moteus.aux.SineCosine::Config


moteus.aux.AuxConfig *-- moteus.aux.Spi


moteus.aux.AuxConfig *-- moteus.aux.Spi::Config


moteus.aux.AuxConfig *-- moteus.aux.UartEncoder


moteus.aux.AuxConfig *-- moteus.aux.UartEncoder::Config


moteus.aux.AuxHardwareConfig *-- moteus.aux.AuxPinConfig


moteus.AuxPort "2" *-- moteus.AS5047


moteus.AuxPort *-- moteus.Aksim2


moteus.AuxPort *-- moteus.AuxADC


moteus.AuxPort *-- moteus.AuxADC::AuxInfo


moteus.AuxPort "3" *-- moteus.aux.AuxConfig


moteus.AuxPort *-- moteus.aux.AuxHardwareConfig


moteus.AuxPort *-- moteus.aux.AuxStatus


moteus.AuxPort *-- moteus.IcPz


moteus.AuxPort o-- moteus.MillisecondTimer


moteus.AuxPort *-- moteus.Stm32G4DmaUart


moteus.AuxPort *-- moteus.Stm32I2c


moteus.AuxPort *-- moteus.aux.Stm32Index


moteus.AuxPort *-- moteus.aux.Stm32Quadrature


moteus.aux.AuxStatus *-- moteus.aux.AuxError


moteus.aux.AuxStatus *-- moteus.aux.Hall


moteus.aux.AuxStatus *-- moteus.aux.Hall::Status


moteus.aux.AuxStatus *-- moteus.aux.I2C


moteus.aux.AuxStatus *-- moteus.aux.I2C::Status


moteus.aux.AuxStatus *-- moteus.aux.Index


moteus.aux.AuxStatus *-- moteus.aux.Index::Status


moteus.aux.AuxStatus *-- moteus.aux.Quadrature


moteus.aux.AuxStatus *-- moteus.aux.Quadrature::Status


moteus.aux.AuxStatus *-- moteus.aux.SineCosine


moteus.aux.AuxStatus *-- moteus.aux.SineCosine::Status


moteus.aux.AuxStatus *-- moteus.aux.Spi


moteus.aux.AuxStatus *-- moteus.aux.Spi::Status


moteus.aux.AuxStatus *-- moteus.aux.UartEncoder


moteus.aux.AuxStatus *-- moteus.aux.UartEncoder::Status


moteus.BldcServo::Control "2" *-- moteus.Vec3


moteus.BldcServoCommandData *-- moteus.BldcServoMode


moteus.BldcServoCommandData "2" *-- moteus.Vec3


moteus.BldcServoConfig "2" *-- moteus.PID


moteus.BldcServoConfig "2" *-- moteus.PID::Config


moteus.BldcServoConfig *-- moteus.SimplePI


moteus.BldcServoConfig *-- moteus.SimplePI::Config


moteus.BldcServoStatus *-- moteus.BldcServoMode


moteus.BldcServoStatus "2" *-- moteus.PID


moteus.BldcServoStatus "2" *-- moteus.PID::State


moteus.BldcServoStatus "2" *-- moteus.SimplePI


moteus.BldcServoStatus "2" *-- moteus.SimplePI::State


moteus.BldcServoStatus *-- moteus.errc


moteus.ClockManager o-- moteus.MillisecondTimer


moteus.FDCanMicroServer o-- moteus.FDCan


moteus.IcPz o-- moteus.MillisecondTimer


moteus.IcPz *-- moteus.Stm32Spi


moteus.MotorPosition o-- moteus.aux.AuxConfig


moteus.MotorPosition o-- moteus.aux.AuxStatus


moteus.MotorPosition *-- moteus.BldcServoMotor


moteus.Stm32BitbangSpi o-- moteus.MillisecondTimer


moteus.Stm32G4DmaUart *-- moteus.Stm32Serial


moteus.Stm32I2c::Options *-- moteus.I2cMode


moteus.aux.Stm32Index *-- moteus.aux.AuxError


moteus.aux.Stm32Quadrature *-- moteus.aux.AuxError


moteus.aux.Stm32Quadrature "2" *-- moteus.aux.Quadrature


moteus.aux.Stm32Quadrature *-- moteus.aux.Quadrature::Config


moteus.aux.Stm32Quadrature o-- moteus.aux.Quadrature::Status


moteus.aux.Stm32Quadrature "2" *-- moteus.Stm32GpioInterruptIn


moteus.TimingInput *-- moteus.AnalogFilter


moteus.TimingInput *-- moteus.I2cMode






/' Nested objects '/

moteus.AuxADC +-- moteus.AuxADC::AdcConfig


moteus.AuxADC +-- moteus.AuxADC::AuxInfo


moteus.AuxADC +-- moteus.AuxADC::PinConfig


moteus.AuxPort +-- moteus.AuxPort::I2cState


moteus.AuxPort +-- moteus.AuxPort::SpiDefault


moteus.BldcServo +-- moteus.BldcServo::Control


moteus.BldcServo +-- moteus.BldcServo::Options


moteus.BldcServoStatus +-- moteus.BldcServoStatus::Dwt


moteus.ClockManager +-- moteus.ClockManager::Config


moteus.Drv8323 +-- moteus.Drv8323::Config


moteus.Drv8323 +-- moteus.Drv8323::OcpMode


moteus.Drv8323 +-- moteus.Drv8323::Options


moteus.Drv8323 +-- moteus.Drv8323::PwmMode


moteus.Drv8323 +-- moteus.Drv8323::Status


moteus.FDCan +-- moteus.FDCan::Config


moteus.FDCan +-- moteus.FDCan::Filter


moteus.FDCan +-- moteus.FDCan::FilterAction


moteus.FDCan +-- moteus.FDCan::FilterConfig


moteus.FDCan +-- moteus.FDCan::FilterMode


moteus.FDCan +-- moteus.FDCan::FilterType


moteus.FDCan +-- moteus.FDCan::Options


moteus.FDCan +-- moteus.FDCan::Override


moteus.FDCan +-- moteus.FDCan::Rate


moteus.FDCan +-- moteus.FDCan::SendOptions


moteus.FirmwareInfo +-- moteus.FirmwareInfo::SerialNumber


moteus.aux.Hall +-- moteus.aux.Hall::Config


moteus.aux.Hall +-- moteus.aux.Hall::Status


moteus.aux.I2C +-- moteus.aux.I2C::Config


moteus.aux.I2C +-- moteus.aux.I2C::DeviceConfig


moteus.aux.I2C +-- moteus.aux.I2C::DeviceStatus


moteus.aux.I2C +-- moteus.aux.I2C::Status


moteus.aux.I2C::DeviceConfig +-- moteus.aux.I2C::DeviceConfig::Type


moteus.IcPz +-- moteus.IcPz::ConfigValue


moteus.IcPz +-- moteus.IcPz::Mode


moteus.IcPz +-- moteus.IcPz::Options


moteus.IcPz +-- moteus.IcPz::Status


moteus.aux.Index +-- moteus.aux.Index::Config


moteus.aux.Index +-- moteus.aux.Index::Status


moteus.MotorPosition +-- moteus.MotorPosition::Config


moteus.MotorPosition +-- moteus.MotorPosition::PllFilterConstants


moteus.MotorPosition +-- moteus.MotorPosition::SourceConfig


moteus.MotorPosition +-- moteus.MotorPosition::SourceStatus


moteus.MotorPosition +-- moteus.MotorPosition::Status


moteus.MotorPosition::Config +-- moteus.MotorPosition::Config::Output


moteus.MotorPosition::SourceConfig +-- moteus.MotorPosition::SourceConfig::Reference


moteus.MotorPosition::SourceConfig +-- moteus.MotorPosition::SourceConfig::Type


moteus.MotorPosition::Status +-- moteus.MotorPosition::Status::Error


moteus.MotorPosition::Status +-- moteus.MotorPosition::Status::Homed


moteus.PID +-- moteus.PID::ApplyOptions


moteus.PID +-- moteus.PID::ApplyOptions


moteus.PID +-- moteus.PID::Config


moteus.PID +-- moteus.PID::Config


moteus.PID +-- moteus.PID::State


moteus.PID +-- moteus.PID::State


moteus.aux.Pin +-- moteus.aux.Pin::Mode


moteus.aux.Pin +-- moteus.aux.Pin::Pull


moteus.aux.Quadrature +-- moteus.aux.Quadrature::Config


moteus.aux.Quadrature +-- moteus.aux.Quadrature::Status


moteus.SimplePI +-- moteus.SimplePI::Config


moteus.SimplePI +-- moteus.SimplePI::State


moteus.aux.SineCosine +-- moteus.aux.SineCosine::Config


moteus.aux.SineCosine +-- moteus.aux.SineCosine::Status


moteus.aux.Spi +-- moteus.aux.Spi::Config


moteus.aux.Spi +-- moteus.aux.Spi::Status


moteus.aux.Spi::Config +-- moteus.aux.Spi::Config::Mode


moteus.Stm32BitbangSpi +-- moteus.Stm32BitbangSpi::Options


moteus.Stm32G4AsyncUart +-- moteus.Stm32G4AsyncUart::Options


moteus.Stm32G4DmaUart +-- moteus.Stm32G4DmaUart::Options


moteus.Stm32GpioInterruptIn +-- moteus.Stm32GpioInterruptIn::Callback


moteus.Stm32I2c +-- moteus.Stm32I2c::Mode


moteus.Stm32I2c +-- moteus.Stm32I2c::Options


moteus.Stm32I2c +-- moteus.Stm32I2c::ReadStatus


moteus.Stm32Serial +-- moteus.Stm32Serial::Options


moteus.Stm32Spi +-- moteus.Stm32Spi::Options


moteus.StreamWriter +-- moteus.StreamWriter::Data


moteus.aux.UartEncoder +-- moteus.aux.UartEncoder::Config


moteus.aux.UartEncoder +-- moteus.aux.UartEncoder::Status


moteus.aux.UartEncoder::Config +-- moteus.aux.UartEncoder::Config::Mode


moteus.Uuid +-- moteus.Uuid::Data




@enduml
